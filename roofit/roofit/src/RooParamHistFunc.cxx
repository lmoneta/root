/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 
#include "RooParamHistFunc.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include "RooRealVar.h"
#include <math.h> 
#include "TMath.h" 


using namespace std ;


ClassImp(RooParamHistFunc) 
  ;  


RooParamHistFunc::RooParamHistFunc()
  : _dh(0) {
}

////////////////////////////////////////////////////////////////////////////////
/// Populate x with observables

RooParamHistFunc::RooParamHistFunc(const char *name, const char *title, const RooAbsArg& x, RooDataHist& dh, Bool_t paramRelative) :
  RooAbsReal(name,title), 
  _x("x","x",this),
  _p("p","p",this),
  _dh((RooDataHist *) &dh),
  _relParam(paramRelative)
{ 
  _x.add(x) ;

  // Now populate p with parameters 
  RooArgSet allVars ;
  for (Int_t i=0 ; i<_dh->numEntries() ; i++) {
    _dh->get(i) ;
    const char* vname = Form("%s_gamma_bin_%i",GetName(),i) ;
    RooRealVar* var = new RooRealVar(vname,vname,0,1000) ;    
    var->setVal(_relParam ? 1 : _dh->weight()) ;
    var->setConstant(kTRUE) ;
    allVars.add(*var) ;
    _p.add(*var) ;
  }
  addOwnedComponents(allVars) ;
} 


////////////////////////////////////////////////////////////////////////////////

RooParamHistFunc::RooParamHistFunc(const char *name, const char *title, const RooAbsArg &x, RooDataHist& dh, const RooParamHistFunc& paramSource, Bool_t paramRelative) :
  RooAbsReal(name,title), 
  _x("x","x",this),
  _p("p","p",this),
  _dh((RooDataHist *) &dh),
  _relParam(paramRelative)
{ 
  // Populate x with observables
  _x.add(x) ;
  
  // Now populate p with existing parameters  
  _p.add(paramSource._p) ;
} 



////////////////////////////////////////////////////////////////////////////////

RooParamHistFunc::RooParamHistFunc(const RooParamHistFunc& other, const char* name) :  
  RooAbsReal(other,name), 
  _x("x",this,other._x),
  _p("p",this,other._p),
  _dh(other._dh),
  _relParam(other._relParam)
{ 
} 



////////////////////////////////////////////////////////////////////////////////

Double_t RooParamHistFunc::evaluate() const 
{ 
  Int_t idx = _dh->getIndex(_x,kTRUE) ;
  Double_t ret = ((RooAbsReal*)_p.at(idx))->getVal() ;
  if (_relParam) {
    Double_t nom = getNominal(idx) ;
    ret *= nom ;
  }
  return  ret ;
} 



////////////////////////////////////////////////////////////////////////////////

Double_t RooParamHistFunc::getActual(Int_t ibin) 
{
  return ((RooAbsReal&)_p[ibin]).getVal() ;
}



////////////////////////////////////////////////////////////////////////////////

void RooParamHistFunc::setActual(Int_t ibin, Double_t newVal) 
{
  ((RooRealVar&)_p[ibin]).setVal(newVal) ;
}



////////////////////////////////////////////////////////////////////////////////

Double_t RooParamHistFunc::getNominal(Int_t ibin) const
{
  return _dh->weight(*_dh->get(ibin), 0, kTRUE, kFALSE) ;
}
  

////////////////////////////////////////////////////////////////////////////////

Double_t RooParamHistFunc::getNominalError(Int_t ibin) const
{
  _dh->get(ibin) ;
  return _dh->weightError() ;
}
  


////////////////////////////////////////////////////////////////////////////////
/// Return sampling hint for making curves of (projections) of this function
/// as the recursive division strategy of RooCurve cannot deal efficiently
/// with the vertical lines that occur in a non-interpolated histogram

list<Double_t>* RooParamHistFunc::plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const
{
  // Check that observable is in dataset, if not no hint is generated
  RooAbsLValue* lvarg = dynamic_cast<RooAbsLValue*>(_dh->get()->find(obs.GetName())) ;
  if (!lvarg) {
    return 0 ;
  }

  // Retrieve position of all bin boundaries
  const RooAbsBinning* binning = lvarg->getBinningPtr(0) ;
  Double_t* boundaries = binning->array() ;

  list<Double_t>* hint = new list<Double_t> ;

  // Widen range slighty
  xlo = xlo - 0.01*(xhi-xlo) ;
  xhi = xhi + 0.01*(xhi-xlo) ;

  Double_t delta = (xhi-xlo)*1e-8 ;
 
  // Construct array with pairs of points positioned epsilon to the left and
  // right of the bin boundaries
  for (Int_t i=0 ; i<binning->numBoundaries() ; i++) {
    if (boundaries[i]>=xlo && boundaries[i]<=xhi) {
      hint->push_back(boundaries[i]-delta) ;
      hint->push_back(boundaries[i]+delta) ;
    }
  }

  return hint ;
}


////////////////////////////////////////////////////////////////////////////////
/// Return sampling hint for making curves of (projections) of this function
/// as the recursive division strategy of RooCurve cannot deal efficiently
/// with the vertical lines that occur in a non-interpolated histogram

std::list<Double_t>* RooParamHistFunc::binBoundaries(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const 
{
  // Check that observable is in dataset, if not no hint is generated
  RooAbsLValue* lvarg = dynamic_cast<RooAbsLValue*>(_dh->get()->find(obs.GetName())) ;
  if (!lvarg) {
    return 0 ;
  }

  // Retrieve position of all bin boundaries
  const RooAbsBinning* binning = lvarg->getBinningPtr(0) ;
  Double_t* boundaries = binning->array() ;

  list<Double_t>* hint = new list<Double_t> ;

  // Construct array with pairs of points positioned epsilon to the left and
  // right of the bin boundaries
  for (Int_t i=0 ; i<binning->numBoundaries() ; i++) {
    if (boundaries[i]>=xlo && boundaries[i]<=xhi) {
      hint->push_back(boundaries[i]) ;
    }
  }

  return hint ;
}

namespace {
    bool fullRange(const RooAbsArg& x, const RooAbsArg& y ,const char* range)
    {
      const RooAbsRealLValue *_x = dynamic_cast<const RooAbsRealLValue*>(&x);
      const RooAbsRealLValue *_y = dynamic_cast<const RooAbsRealLValue*>(&y);
      if (!_x || !_y) return false;
      if (!range || !strlen(range) || !_x->hasRange(range) ||
	  _x->getBinningPtr(range)->isParameterized()) {
	// parameterized ranges may be full range now, but that might change,
	// so return false
	if (range && strlen(range) && _x->getBinningPtr(range)->isParameterized())
	    return false;
	return (_x->getMin() == _y->getMin() && _x->getMax() == _y->getMax());
      }
      return (_x->getMin(range) == _y->getMin() && _x->getMax(range) == _y->getMax());
    }
}


Int_t RooParamHistFunc::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, 
						const char* rangeName) const 
{

  RooFIter it = _x.fwdIterator();
  Int_t code = 0, frcode = 0, n = 0;
  for (RooAbsArg *pa = 0; (pa = it.next()); ++n) {
    if (allVars.find(*pa)) {
      code |= 2 << n;
      analVars.add(*pa);
      if (fullRange(*pa, *pa, rangeName)) {
	frcode |= 2 << n;
      }
    }
  }

  if (code == frcode) {
    // integrate over full range of all observables - use bit 0 to indicate
    // full range integration over all observables
    code |= 1;
  }

  return (code >= 2) ? code : 0;
}




////////////////////////////////////////////////////////////////////////////////
/// Implement analytical integrations by doing appropriate weighting from  component integrals
/// functions to integrators of components

Double_t RooParamHistFunc::analyticalIntegral(Int_t code, const char* rangeName) const 
{
  if (code == 0) return 0;

  // else integrate in range
  Double_t binlow = 0;
  Double_t binhigh = 0;
  RooAbsRealLValue* rlv = dynamic_cast<RooAbsRealLValue*>(_x.at(0));
  if (rlv) {
    const RooAbsBinning* binning = rlv->getBinningPtr(rangeName);
    if (rangeName && rlv->hasRange(rangeName)) {
      binlow = rlv->getMin(rangeName);
      binhigh = rlv->getMax(rangeName);
    } else if (binning) {
      if (!binning->isParameterized()) {
        binlow = binning->lowBound();
        binhigh = binning->highBound();
      } else {
        binlow = binning->lowBoundFunc()->getVal();
        binhigh = binning->highBoundFunc()->getVal();
      }
    }
  }

  RooFIter iter = _p.fwdIterator() ;
  RooAbsReal* p ;
  Double_t ret(0) ;
  Int_t i(0) ;
  while((p=(RooAbsReal*)iter.next())) {
    RooRealVar *rx = (RooRealVar *) _x.at(0);
    Double_t bin = 0;
    if (rx->getBinning().binLow(i) >= binlow &&
        rx->getBinning().binLow(i) < binhigh) {
      bin = p->getVal() ; 
      if (_relParam) bin *= getNominal(i)*rx->getBinWidth(i);
    }
    ++i;
    ret += bin ;
  }
  
  return ret;
}


